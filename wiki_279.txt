== Fracture Modifier Dokumentation ==
für Blender 2.79, Fracture Modifier Zweig mit offiziellen Release von blender verschmolzen
<br /> <br /> <br />

[[File:Scorpion81_Fracture_Modifier_2.79_custom_splash.jpg‎|center|text-below|400px|Splash with example]]

<br />
= Grundkonzept =

<b> Dieses Tool macht es Spaß, Dinge zu brechen! Fraktur! Zerschmettern! Explodieren! Zerstören! Jetzt mit Biege-Metall, deformieren Kunststoff und gefälschte Tuch mit Physik starren Körper gemacht! </b> Viele Optionen sind verfügbar, um die Art der resultierenden Objekte zu wählen und wie sie auseinander brechen und animieren. Kundenspezifische Helfer erlauben eine detaillierte Detailsteuerung und Formgebung des Frakturmusters. Es ist ein Modifikator, so dass es nicht zerstörerisch für die ursprüngliche Geometrie ist, es sei denn angewendet und es kann mit anderen Modifikatoren im Stapel interagieren. Der Modifikator arbeitet nahtlos mit der Bullet Physics-Bibliothek zusammen, um Simulationen und Animationen zu machen. Mit der zusätzlichen Leistung eines anspruchsvollen Contraints-Systems ist es eine funktionsreiche Zerstörungsplattform.

<b> Der Modifikator ist sehr schnell </b> selbst in der 1.000 und oberhalb des Shard-Bereichs und hält alle resultierenden Scherben im Modifikator, so dass sie den Outliner nicht stören. Der schnelle Workflow gibt den Künstlern ein leistungsfähiges Werkzeug für Experimente und Feinabstimmungsergebnisse für beide Standbilder von gebrochenen Objekten und physikbasierten Zerstörungsansimationen und visuellen Effekte.

<b> Der Fracture Modifier ist eng mit dem Bullet Physics Library Subsystem </b> in Blender für Animations- und Simulationszwecke integriert. Es verfügt über ein fortgeschrittenes automatisches und leicht angepasstes Constraint-Gebäudesystem mit mehreren Einstellungen, um die Ergebnisse der Simulation künstlerisch zu steuern.

<b> Obwohl der Bruchmodifikator ein Zweig ist (siehe unten), hat er ein aktives Entwicklungsteam und eine große Benutzerbasis. </b> Das Entwicklungsteam arbeitet mit Blender Core-Entwicklern bei der Aktualisierung von Blender v2.8 Speicherkapazitäten in die offiziellen Veröffentlichungen aufgenommen werden.

<br />

<b> HINWEIS: </b> Der Fracture Modifier ist ein benutzerdefinierter Build aus einem Code-Zweig von Blender und nicht verfügbar in den offiziellen Blender-Programm-Releases. Es ist kein Python-Addon. Weitere Informationen zum Download und zur Verwendung der FM-Filiale finden Sie weiter unten.

<br />

= Gaetting Begann =

[[File:200px-Scorpion81-User_Fracture_Documentation_Main_Panel.png|right|text-above|287px|Main Panel]]

{| class="wikitable"
Der grundlegende Workflow ist:
#Wählen Sie ein Objekt zum Bruch
#Go zum Physik-Tab im Eigenschaftseditor
#Wählen Sie die Physik für: Fraktur
#Klicken Sie auf "Bruch ausführen"
#Press {{Shortcut|alt|a}} zum Starten und Erzeugen der starren Körpersimulation

Hinweis: Stellen Sie sicher, dass es eine passive starre Körper Grundplatte unter dem Objekt für sie zu kollidieren, so wird es in die Scherben zu trennen.
<br /> <br />
Für alle Einstellungen "oben" die Schaltfläche "Ausführen" und die Punktquelle und den Bruchprozentsatz, müssen Sie immer den Modifikator auf dem starren Körper-Cache-Start-Frame, normalerweise Frame 1, erneut ausführen, um einen Effekt zu sehen.
|}

<br />

= Nützliche Links und Downloads =
(HINWEIS: um auch auf dieser Seite zu bleiben, klicken Sie mit der rechten Maustaste auf die Links und klicken Sie auf eine neue Registerkarte oder ein Fenster.)

* [http://blenderartists.org/forum/showthread.php?343637 BlenderArtists.org Support Forum Thread]

* IRC Chat Support Channel #blenderfracture auf freenode.net oder bei http://webchat.freenode.net

* [https://www.facebook.com/FractureModifier/ Facebook Seite]

* Blender auf Stack Exchange: [https://blender.stackexchange.com/search?q=fracture+modifier Fracture Modifier search]

==DF-VFX Hosted Builds==

* http://df-vfx.de/fracturemodifier/ Windows, Linux und Mac OS X - Danke an DF-VFX für das Hosting dieser
* http://df-vfx.de/fracturemodifier/learn-fracturing/ DF-VFX's hervorragende Tutorials Seite

(HINWEIS: Die aktuellen Builds werden mit Blender v2.79 zusammengeführt und im Allgemeinen sind die FM-Builds, die mit offiziellen Releases zusammengeführt werden, in der Regel wöchentlich oder zwei nach den offiziellen Releases verfügbar. Es werden nur 64-Bit-Builds bereitgestellt.)

==Andere Links==
(HINWEIS: Jens' Build ist immer die neueste Entwicklung und Test-Build.Es ist nur in 64-Bit-Linux mit statischen libs für den Einsatz auf die meisten distros.Benutzen Sie unsere Blender Artist Forum Thread zu sehen, wenn diese freigegeben werden.Manchmal Kai's Graphicall bauen wird einen Entwicklungsaufbau auch bieten.)

* http://www.jensverwiebe.de/Blender/blender_fracture_modifier_linux64_latest.tar.xz Linux 64 Bit bauen
* http://www.graphicall.org/1148 Windows 64 bit Graphicall.org Build

==Quellcode==

Der Bruchmodifikator ist ein Spezialzweig von Blender. Es verwendet Methoden, die derzeit nicht mit den internen Speicherfunktionen von Blender kompatibel sind. Der FM-Zweig wird zusammengeführt und kann anstelle von offiziellen Releases mit vollständiger Kompatibilität anderer Release-Features verwendet werden. Ein "config" -Ordner unter dem Ordner 2.79 kann vom Benutzer erstellt werden, um die Freigabe von Einstellungen mit anderen installierten Blender-Versionen zu vermeiden. Auf diese Weise kann die FM separat getestet werden.

<b>GitHub repo</b>
https://github.com/scorpion81/blender-fracture/tree/fracture_modifier
<br /> (HINWEIS: Sie müssen manuell über die Skripts und Gebietsschema-Ordner aus einem anderen Mix-Quellordner kopieren.)

<b>Helper-Addon und Pie-Menü Quellcode </b> https://github.com/scorpion81/blender-fracture-helper

<b>Diese Dokumentation Quellcode </b> https://github.com/JT-a/blender-fracture-docs Beiträge Willkommen.

<b>Blender.org offizieller Zweig </b> https://git.blender.org/gitweb/gitweb.cgi/blender.git/shortlog/refs/heads/fracture_modifier
<br /> (HINWEIS: Sie können auch den Zweig auschecken, wenn Sie herunterladen und mit Blenders Quellcode-Master über Git arbeiten.)

Wenn Sie Fragen haben, die den Fraktur-Modifikator-Zweig aufbauen, bitten wir um Hilfe zu unserem Blender-Künstler-Thread oder in unserem IRC-Chat-Raum, der oben erwähnt wurde, oder das [https://wiki.blender.org/index.php/Dev:Doc/Building_Blender Building Blender Wiki Seite].

<b> HINWEIS: </b> Unsere spannenden Unterentwicklungsfunktionen stehen zur Verfügung, wenn Sie sich aus dem Quellcode-Repo aufbauen. Fühlen Sie sich frei, Fragen über Funktionen in der Entwicklung in unseren oben genannten Kommunikationskanälen zu stellen.

<br />

= Neue Verbesserungen =
Aktuelle Verbesserungen, Ergänzungen und Klarstellungen sind hier für jetzt aber schließlich werden in den Rest der docs integriert werden.

<b>Einige Verbesserungen im v2.79 Based Build:</b>
* GUI-Workflow-Anpassungen, immer verbessern dies für diejenigen mit einem Bedarf an Geschwindigkeit!
* Schneide-Algorithmus und Einstellungen für Material-Typen Biegen von Metall, deformierenden Kunststoff, gefälschte Tuch
* [https://en.wikipedia.org/wiki/Plasticity_(physics) deformierender plastik] -Einstellungen bieten die Möglichkeit, die Form-Response-Ausbeute zu kontrollieren
* Die neuen Material-Typen sind starre Körper-basierte, so dass sie völlig Physik sim kompatibel sind
* Verbesserte Bruchhelfer-Addon und ein neu hinzugefügtes Tortenmenü für den 3D-View-Workflow
* Neue Addon-Features beinhalten einen Zeit- / Geschwindigkeitsregler und dynamische Lackgesteuerte Funktionen
* Das Addon's Smoke / Dust / Debris System wurde verbessert, um Dynamic Paint zu verwenden
* Fortsetzung der Entwicklung von fortschrittlichen Constraint-Management-System über Standard-Mixer
* Weitere Einstellungen funktionieren nun auch auf Clustern
* Neue Automerge-Einstellung für Material-Typ-Ergebnisse und andere clever Kombinationen verwendet
* Boolean Solver ist nun zwischen den internen Carve- oder BMesh-Methoden von Blender auswählbar
* Verbesserte Konvertierung zu Keyframed-Objekten mit neuen zusätzlichen Einstellungen
* Trigger Management Verbesserung vor allem für "kinetische" Interaktion und Stoppen
* Shadow Catching ist ab sofort im Blender 2.79 verfügbar und nun im FM-Workflow verwendbar

HINWEIS: Der Bruchmodifikator ist ein anspruchsvolles Werkzeug und eine Plattform, die absichtlich mit Experimentieren und Feinsteuerung konzipiert wurde. So sind unerwartete und unerwünschte Ergebnisse gelegentlich Teil des kreativen Prozesses und des Workflows. Bruch EIN!

<br />

= Brucheinstellungen Panel =
(im Register "Eigenschaften-Editor")
<br /> Hinweis: Im Allgemeinen werden viele Einstellungen am besten mit dem Experimentieren mit ihnen und Kombinationen verwendet, um die gewünschten Ergebnisse zu finden.

== Voreinstellungen ==
Sie können alle Einstellungen für Fracture Settings, Fracture Constraint Settings und Fracture Utilities in Presets speichern. Nachdem Sie ein bestehendes Preset ausgewählt haben, müssen Sie Fracture nachträglich ausführen, um die geänderten Einstellungen anzuwenden.
 
Es wird eine Fehlermeldung angezeigt, wenn Sie versuchen, eine Voreinstellung vor dem Hinzufügen eines ersten zu wählen.
Hier gilt auch die gleiche Regel über das Sein auf Rahmen 1 oder der Startrahmen des starren Körper-Cache gilt auch. Das Bruch wird nicht anders ausgeführt. <br />
Aufgrund von Problemen / Abstürzen mit Frakturen auf verschiedenen Frames war diese Einschränkung notwendig, um zu implementieren.

== Bruchmodus ==
Vorgebrochen - Bruch das Mesh einmal vor der Simulation <br />
Extern (WIP) - Packen Sie externe Mesh-Objekte als Inseln und Einschränkungen in den Modifikator <br />
Dynamic (WIP) - Fragment das Netz dynamisch während der Simulation

== Bruchalgorithmus Kurze Erläuterung ==
<b> Voronoi </b> ist die Basismethode überall. Es zerlegt die Objekt-Bounding Box über die voro ++ -Bibliothek zu der gegebenen Shard Count, wenn im Uniform-Modus unter Fracture Point Source in Advanced Fracture Settings. Sie haben zwei Hauptmöglichkeiten, um Scherben der tatsächlichen Geometrie zu bekommen: Boolean und Bisect.

<b> Boolean </b> (Standard) ist gut für geschlossene Formen, kann aber Fehler werfen, wodurch das Ergebnis unbrauchbar wird, aber alle inneren Gesichter werden geschlossen.
Für Boolean stellen Sie sicher, dass Sie wasserdichte Maschen haben, auch wenn Sie kleine Meshes haben, im Editiermodus skalieren und im Objektmodus wieder abbauen, so dass das interne Mesh groß genug ist, um Float-Ungenauigkeiten zu vermeiden. Wenn die Größe zu klein wird, treten boolesche Fehler wahrscheinlich auf.

<b> Fractal Boolean </b> voronoi Zellen werden für eine boolesche Überschneidung mit der ursprünglichen Geometrie verwendet. Es wird technisch nicht voronoi verwendet, sondern nur Cutter-Ebenen, die nicht von den Zellen abweichen. Kleinere Scherben funktionieren nicht gut (das Partikelsystem). Für kleinere Scherben ist es besser, Voronoi + Boolean oder Voronoi + Bisect zu benutzen.

<b> Bisect </b> kommt aus dem Mixer und schneidet das Gitter in Hälften entlang der Zelle (als Ebenen), hält immer den inneren Teil und schneidet die nächste Hälfte mit dem nächsten Gesicht und so weiter ab, bis ein Stück in der Form der Zelle ist ausgeschnitten. Es füllt nicht die inneren Gesichter, also musst du Bisect + Fill dafür benutzen. Aber Vorsicht, es ist nicht so zuverlässig wie boolean, so dass viele Gesichter offen sind. Bisect ist gut für offene Formen, aber mit vielen Zellen kann es langsam sein, aber es macht genau geformte Scherben.
 
<b> Bisect + Fill </b> ist gut für geschlossene Formen auf einfache Geometrie auch. Es wird nicht als boolescher Fehler ausfallen, aber es kann innerliche Gesichter auslassen.
Bisect-Füllung verwendet einen Blender-internen Fill-Algorithmus-Dreieck-Füllung, was in einigen Fällen sehr unzuverlässig ist.

<b> Fast Bisect </b> reduziert die Anzahl der Bisektionen pro Zelle auf 1 Gesicht. Es schafft unterschiedlich geformte Scherben, indem sie die Reste immer wieder halbieren, schneller als herkömmliche Halbachse, weil diese Maschenreste jedes Mal kleiner werden. Fast bisect ist gut für offene Formen, die es nicht füllen kann. Shapes sehen anders aus, aber auch gute Muster konnten erreicht werden (bisher im Uniform-Modus getestet) und es ist deutlich schneller als herkömmliche Bisect. Hinweis: Kleinere Scherben funktionieren nicht mit dem Partikelsystem.

HINWEIS: Fractal Boolean und Fast Bisect arbeiten nur mit Uniform Point Source Set. Andere Quellen werden ignoriert.

<b> Auswahlmöglichkeiten sind: </b> <br />
Voronoi + Fractal Boolean - Benutze Voronoi und Boolesche Kreuzung mit fraktal unterteilten Zellen <br />
Voronoi + Bisect - Verwenden Sie Voronoi und Mesh Bisect als Fraktur Algorithmus, nicht füllen Schnitt Gesichter <br />
Voronoi + Bisect + Fill - Verwenden Sie voronoi und Mesh Bisect als Frakturalgorithmus, füllen Sie geschnittene Gesichter <br />
Voronoi + Boolean (Standard) - Voronoi und Boolesche Kreuzung als Bruchalgorithmus verwenden <br />
Schneller Bisect + Fill - Benutze den schnelleren, aber unterschiedlichen Bisect-Algorithmus und fülle Schnittflächen <br />
Fast Bisect - Verwenden Sie einen schnelleren, aber mehr ungenaue Bisect-Algorithmus, schafft auch hässlichere Shards <br />

<b> Boolean Solver: </b> Selektionen sind Carve oder BMesh. Carve kann einige nicht verteilte Fälle etwas besser behandeln. BMesh ist manchmal schneller, aber es kann Probleme mit einigen Meshes haben. Es ist am besten zu experimentieren und zu sehen, was man besser für verschiedene Maschen macht.

<b> Shard Count: </b> Nur für einheitlichen Modus. Es bestimmt, wie viele rohe voronoi Zellen über die Begrenzungsbox erstellt werden. Die tatsächliche Scherbezählung kann aufgrund der Kreuzung mit der tatsächlichen Geometrie niedriger sein.

<b> Clusterzählung: </b> Es wird empfohlen, es auf 0 zu setzen, um es zu deaktivieren. Es wird es in Verbindung mit Constraints verwendet und bestimmt, wie viele "größere" Verbindungen aus den tatsächlichen Scherben hergestellt werden. Dies ist ein Versuch, ein zweistufiges Breaking-Verhalten über Einschränkungen und stärkere "innere" Schwellen NUR zu fälschen.

<b> Samen: </b> Nur für einheitlichen Modus. Dies ist der Ausgangssaat für die Schaffung einer zufälligen einheitlichen Punktwolke über der Begrenzungsbox. Variieren Sie es geben

<br />

= Erweiterte Fraktureinstellungen =
=== Bruchpunkt Quellmodi ===
Hier können Sie die Punktquelle auf eine beliebige Kombination der fünf Möglichkeiten umstellen. Es wird empfohlen, es auf "Uniform" zu setzen. Modi sind kumulativ. Sie können mehrere Quellen auswählen. Sie addieren sich zu einer kombinierten Punktwolke.

==== Eigene Teilchen ====
Verwenden Sie ein Partikelsystem des gleichen Objekts wie Punktwolkenquelle. Nur ein Partikelsystem pro Objekt unterstützt. Verwenden Sie keine Mehrfachen, sonst könnte das Verhalten unbestimmt sein. Die Anzahl der Teilchen wird auf die Anzahl der Scherben über der Begrenzungsbox abgebildet.
Empfohlene Particle System-Einstellungen sind: Volume, Random, alle Partikel in 1 Frame emittiert. Ansonsten gibt es Probleme, zum Beispiel mit Booleschen, wenn sie von Gesichtern emittieren, besonders wenn Punkte sehr nahe an den Begrenzungsrahmengrenzen sind.

==== Eigene Vertices ====
Jeder Scheitel des Objekts wird zu einem Punkt in der Punktwolke. Es empfiehlt sich, nur bei niedrigen Poly- bzw. Low-Scheitel-Objekten zu verwenden. Kann auch zu Problemen führen, wenn Punkte in der Nähe von Bounding Box Grenzen kommen.

==== Extra Partikel ====
Sie können ein Partikelsystem auf einem anderen Objekt mit den gleichen empfohlenen Einstellungen erstellen und zu einer Helpergruppe hinzufügen. Dann geben Sie diese Gruppe in der Extragruppe an. Auf diese Weise kann ein ungleichmäßiger Bruch entstehen. Der "Eigene Partikel" -Modus sollte auch bei der Manipulation der Partikelsystem-Emission über eine Textur zum Beispiel einen ungleichmäßigen Bruch aufweisen.

==== Extra Vertices ====
Jeder Scheitel eines oder mehrerer Objekte wird zu Quellpunkten für das Brechen. Sie fügen diese Helper-Objekte zu einer Gruppe hinzu und geben sie als Extra-Gruppe an. Wenn Sie sowohl Partikel- als auch Vertex-Optionen ausgewählt haben, erhalten Sie eine kombinierte Punktwolke. Hier auch besser niedrige Polyobjekte verwenden.

==== Fettbutter ====
<b> WARNUNG: </b> sehr experimentelles Merkmal - kann abstürzen! NICHT BEWEGEN Sie das Objekt von Hand aus "Fett Bleistift Zeichnung Bereich", nicht einmal teilweise! <br />
Um mit diesem Feature zu experimentieren, ziehen Sie Punkte oder kürzere Linien. Jeder Strich wird ein Punktwolkenpunkt. Hier hilft es, die Gesamtmenge der Quellpunkte mit der "Prozentsatz" -Einstellung unter "Extra-Gruppe" zu begrenzen. Bei längeren Strichen riskierst du sonst eine riesige Menge an verformten Scherben, ein langer Bruchvorgang und evtl. sogar bei Bruch oder in der Simulation.

Verwenden Sie Greasepencil Edges: (WIP, nur für Testzwecke nur für jetzt, derzeit nicht mit anderen Pointources kombinierbar.) Verwenden Sie GP-Linien, die intern in Cutter-Ebenen umgewandelt werden. <br />
Hinweis: Striche müssen außerhalb des Objekts beginnen und enden, auf das sie gezogen werden, und arbeitet nur mit dem Greasepencil im OBJECT-Modus.

Greasepencil Offset: "Länge" der Cutterplane, muss das zu schneidende Objekt überschreiten. <br />
Greasepencil Decimate (reduziert die Anzahl der Punkte in einem Schlaganfall für die Cutter-Ebene verwendet. <br />
Cutter Axis: momentan kann es nur die Linie zu einer Ebene entlang globaler X, Y oder Z projizieren.

==== Uniform ====
(Standard) Verwenden Sie eine zufällige generierte Punktwolke, die über die gesamte Begrenzungsbox erzeugt wird.

==== Zusätzliche erweiterte Einstellungen ====
<b> Extra-Gruppe: </b> Geben Sie eine zusätzliche Partikelsystemgruppe oder eine zusätzliche Vertexgruppe aus einem anderen Objekt an. Dies muss in eine Gruppe gesetzt werden und dann kann es mit dem Modifikator verbunden werden, um weitere Details hinzuzufügen. Siehe auch Extra Partikel, zusätzliche Vertices und zusätzliche Workflow-Informationen.

<b> Unterobjektgruppe: </b> Verbinden Sie mehrere abgeleitete Maschen verschiedener Objekte mit unterschiedlichen Modifikatoreinstellungen zusammen in einem "Kollektor" -Objekt. Siehe auch Abschnitt Advanced Workflow Information.

<b> Cutter Group: </b> Ein Satz von Objekten, um boolesche Schnitte zu machen.

<b> Verwenden Sie Partikel-Geburtskoordinaten: </b> Geburts- oder simulierte Zustands-Partikelkoordinaten verwenden.

<b> Prozentsatz: </b> Prozentsatz der Summe der Punkte aller ausgewählten Punktquellen, die tatsächlich für Frakturen verwendet werden sollen.

<b> Threshold Vertex Group: </b> Vertex Gruppenname für die Definition gewichteter Schwellenwerte auf verschiedenen Mesh-Parts. Sie können Lackgewichte auf dem Mesh PRIOR bezahlen, um mit Modifier zu brechen. Dies ist bei aktiviertem Modifikator nicht sichtbar. (TODO) Die Gewichte reduzieren den vorgegebenen Schwellenwert durch Multiplikation von Gewichten und Schwellenwerten. Ein Gewicht bei 1 bedeutet volle Schwelle, je niedriger man erhält, desto niedriger ist die Schwelle. (0 -> unbestimmt, TEST ...)

<b> Passive Vertex-Gruppe: </b> Vertex-Gruppenname für die Definition von passiven Mesh-Teilen. Es wird während der starren Körpersimulation statisch bleiben. Sie können passive Teile mit hohen Gewichten analog zu den Schwellen malen. Es wird empfohlen, Gewicht von 1 zu verwenden, da das Gesamtgewicht aller Scheitelpunkte eines Scherbens> 0,5 sein muss, um die Scherbe passiv zu setzen, also bleibt es während der Sim. Die Objekte können entweder aktiv oder passiv sein, da ist nichts dazwischen.

<b> Inner Vertex Group: </b> Vertex-Gruppenname für die Definition von inneren Ecken. Wird Ecken der inneren Gesichter enthalten. Wird nur für Boolean und Bisect + Fill verwendet.

<b> Innerer Falten: </b> eine Falte an den Kanten der inneren Gesichter erzeugen. Während einer Physik-Simulation bildet die innere Falte harte Kanten für glatte Innenflächen. Das funktioniert gut mit Microdisplacement Setup. Es kann in Verbindung mit dem Sub-Oberflächen-Modifikator verwendet werden, um eine bessere Kontrolle des Catmull-Clark-Untergrundes zu ermöglichen, um gerade Kanten zu halten, ohne dass er auf einen einfachen Untergrund zurückfallen muss. <br />
(EG: nützlich bei Mikroverlagerung, die über Subdiv Modifier und Textur nach der FM gesteuert wird)

<br />

= Fracture Constraint Settings Panel für Simulationen =

[[File:User_Fracture_Documentation_Fracture_Simulation.png|right|287px|Fracture Simulation]]
<b> Hinweis: </b> Der Fracture Modifier-Zweig verfügt über ein fortgeschrittenes Constraint-Management-System, das weit überlegen ist als das Standard-Mixer. Das kombiniert mit Bullet Physics Simulationen bietet eine überlegene Ebene der kreativen Kontrolle in Shard Management und Zerstörung Schaffung. Weitere Informationen zu den Einstellungen und Verwendungen finden Sie im Abschnitt "Grundlegendes verstehen".

<b> Verwenden Sie Constraints: </b> Wenn aktiviert, erzeugt es ein leistungsstarkes Bullet-basiertes Custom Constraints System. Es schafft sofort Zwänge zwischen allen Scherben des Objekts. Im Allgemeinen können Sie einen Suchradius oder Kontaktabstand in Blender-Einheiten angeben und die Scherbezählung (pro Insel) beschränken, um die Anzahl der Einschränkungen zu reduzieren und die Simulation zu beschleunigen.

<b> Breakable: </b> Constraints können gebrochen werden, wenn sie einen Impuls über dem Schwellenwert erhält.

<b> Beschränkte Kollision: </b> Lassen Sie beschränkte Scherben miteinander kollidieren. Die eingeschränkten Objekte, deren Einschränkungen noch intakt sind, werden nicht miteinander kollidieren. EG: Fälschungen bei der Verwendung von Punktbegrenzungen und Automerge zum Fake Tuch. Weitere Informationen finden Sie unter Grundlegendes zu Constraints.

<b> Verwenden Sie Compounds: </b> Dies ist eine experimentelle Einstellung, die Bullet-Methoden-Compounds anstelle von festen Constraints verwendet. Angeblich ist das mit weniger wackelnder schneller

<b> Einschränkungsmethode: </b>
<br /> Vertex - Erstellen Sie Einschränkungen basierend auf Abständen zwischen Vertices. Hinweis: Verwenden Sie hier niedrigere Werte. Es verbindet fast immer nur benachbarte Nachbarn mit dem
Abstand zwischen den Eckpunkten der nahe gelegenen Scherben
<br /> Centroid - Erstellen Sie Einschränkungen auf Distanzen zwischen den Zentroiden. Inseln können weiter weg als die angrenzenden, um mehr steife Objekte zu bekommen.
<br /> Also mit einem ist der Abstand zwischen den Schwerpunkten und mit dem anderen ist der Abstand zwischen den Scheiteln.

<b> Einschränkungsgrenze pro Meshisland: </b> Maximale Anzahl von Nachbarn, die pro Mesh-Insel während der Constraint-Erstellung gesucht werden, 0 oder unbegrenzt.

<b> Suchradius: </b> Suchradius einschränken bis zu welchen 2 Mesh-Inseln verbunden sind, 0 für die gesamte Begrenzungsbox. Hinweis: Dies ist eine ältere Einstellung, die die Anzahl der maximalen Verbindungen pro Mesh-Insel und den Radius begrenzt, in dem die Shards gesucht werden, um mit dem aktuellen Shard zu betrachten.

<b> Einschränkungseinstellungen - </b> <br />
<b> Threshold: </b> Es bestimmt, welche Kraft die Einschränkung beeinflussen muss, um sie zu brechen. höhere Schwelle bedeutet, dass es mehr Kraft braucht, um die Einschränkung zu brechen. Es empfiehlt sich, diese Schwellenwerte bei der Verwendung der Standardmasse zu verringern oder die Masse zu erhöhen, um leichtere Pausen zu erhalten. Dies vermeidet das "Gummi" -Verhalten, das bei hohen Schwellenwerten niedrige Massen und "lange Reichweite" Einschränkungen vor allem auftritt.

<b> Cluster Breaking Threshold: </b> Ein hoher Standardwert, der auf Mitglieder in einem Cluster angewendet wird, um die Sekundärfraktur zu fälschen. Tertiäre und höhere Ebenen werden nicht unterstützt, da man Cluster nicht gruppieren kann.

<b> Einschränkung Spezielle Breaking Settings - </b> <br />
<b> Prozentsatz: </b> Wenn der angegebene Prozentsatz der Einschränkungen pro Insel gebrochen ist, dann werden alle verbleibenden Einschränkungen dieser Insel automatisch brechen. Wenn Sie es auf 0 setzen, wird es deaktiviert. Setzen Sie auf hohe Werte, um alle Einschränkungen vollständig zu brechen, die nach Kollision umhergehen könnten, niedrigere Werte machen das Objekt leichter, 25 bedeutet, wenn nur 25% gebrochen sind, zerbrechen auch den Rest.

<b> Winkel: </b> Wenn ein Winkel größer als x Grad zwischen zwei Inseln auftritt, brechen Sie die entsprechende Einschränkung. Dies beschränkt das Biegeverhalten von Zwängen, die dann brechen, wenn es zu viel gebeugt wird.

<b> Distanz: </b> Wenn ein Abstand (Mischereinheiten) größer als x zwischen zwei Inseln ist, brechen Sie die entsprechende Einschränkung, Dies beschränkt das Streckverhalten von Einschränkungen, die brechen, wenn es zu viel gedehnt wird.
 
HINWEIS: Alle 3 Einstellungen sind jetzt auch für Cluster verfügbar.
Der Clusterwinkel gilt nur zwischen Scherben, die zu verschiedenen Clustern gehören. Das bedeutet, dass das Objekt in seine Cluster zerfällt. Wenn Sie einen niedrigen Wert für den regulären Winkel setzen, wird es noch auseinanderfallen.
<br /> Also, wenn Sie einen Cluster Winkel 0.1 und Winkel 2 oder 3 Ihr Objekt wird wahrscheinlich brechen, um seine Cluster zuerst.
<br /> Die gleiche Logik gilt für Distanz und Prozentsatz.

<b> Gewichteter Prozentsatz: </b> Ändern des Bruchanteils durch Schwellengewichte.
<br /> <b> Gewichteter Winkel: </b> Ändern des Bruchwinkels durch Schwellengewichte.
<br /> <b> Gewichteter Abstand: </b> Ändern des Bruchabstandes durch Schwellengewichte.

<b> Solver Iterations: </b> Dies gilt für das gesamte Frakturobjekt und überschreibt die Szeneneinstellung. Höhere Iterationen reduzieren das Wackeln / Gummi-Verhalten, aber die Simulation wird langsamer.

<b> Cluster Solver Iterations Override: </b> Dieser Schieberegler überschreibt die Solver-Iterationen für Zwänge, die zwischen Scherben liegen und zu verschiedenen Clustern gehören. Es sollte ursprünglich betont werden, dass es auch bei der Verwendung von Schwellenwerten zu Clustern geht.

<b> Massenabhängige Schwellenwerte verwenden: </b> Den angegebenen Schwellenwert entsprechend dem Verhältnis der aktuellen Scherbe zu einer Scherbe mit maximaler Masse reduzieren. Wie eine Scherbe mit Masse x hat Schwelle 100, Masse x / 2 hat dann 50. Dadurch können Beschränkungen leichter brechen, ohne die Massen zu verändern und das Gummi-Verhalten zu vermeiden.

<b> Constraint Deform Settings - </b> (Siehe Understanding Constraints unten)
<br /> <b> Deforming Angle: </b> Winkel in Grad oberhalb welcher Einschränkung seine Verformung beibehalten sollte.
<br /> <b> Deforming Distance: </b> Abstand oberhalb welcher Einschränkung seine Verformung beibehalten sollte.
<br /> <b> Cluster Deforming Angle: </b> Winkel in Grad, über dem Cluster-Constraint seine Deformation beibehalten sollte.
<br /> <b> Cluster Deforming Distance: </b> Abstand oberhalb welcher Cluster-Constraint seine Deformation beibehalten sollte.
<br /> <b> Gewichteter deformierender Winkel: </b> Ändern des Verformungswinkels durch Schwellengewichte.
<br /> <b> Gewichteter deformierender Abstand: </b> Änderungsform durch Schwellengewichte ändern.
<br /> <b> Deformierender Schwächungsfaktor: </b> Multipliziert die Bruchschwelle in jeder Iteration mit 1,0 Faktor, um sie bei Deform zu schwächen, 0 zu deaktivieren.

<br />

= Fracture Utilities Panel =
(Siehe Grundlegendes zu Fracture Utilities unten)

<b> Filtergruppe: </b> Grundsätzlich handelt es sich hierbei um eine Gruppe von Objekten (nur Sphären funktionieren gut. Verwenden Sie hier nur einen einfachen Radius), der "Autohide" interaktive Risse zeigt. Also, wenn du ein solches Objekt skalierst, könntest du Fehler machen. Aber das ist im Viewport kaum zu spüren (nur bei Automerge und Show "Wire" auf festen Objekten). Aber wenn es gerendert wird, ist es viel spürbarer.

<b> Autohide Entfernung: </b> Abstand zwischen den Gesichtern, unter denen beide gegenüberliegenden Gesichter ausgeblendet werden sollen.

<b> Automerge Distanz: </b> Abstand zwischen den Flächen, unter denen die Ecken der beiden Gesichter verschmolzen werden sollen.
<br /> Hinweis: Verwenden Sie die oben genannten zwei Einstellungen mit Smooth Objects und Fix Normals, um besser Risse in Glas zum Beispiel zu verbergen. Es gibt eine Leistung Kosten bei der Verwendung dieser. Fix Normalen sollten deaktiviert werden, wenn mit hohen Automerge Distanzen und Voronoi + Bisect. Weitere Informationen finden Sie im Abschnitt "Erweiterte Workflow-Informationen" unten.

<b> Halten Sie Verzerrung: </b> Ob die Verzerrung auf zerrissenen verschmutzten Scherben beharrlich ist oder nicht. Verwenden Sie, um interessantere Risskanten zu machen.

<b> Führen Sie Merge aus: </b> Ob die vorbereitete Automerged-Geometrie tatsächlich geschweißt werden soll oder nicht. Es schweißt tatsächlich die Geometrie, um glatter aussehende Normalen zu erhalten, wenn Shade Smooth aktiviert ist (was auch für Fake Cloth, Subsurface und Smooth Modifikatoren verwendet werden soll.)

<b> Fix Normals: </b> (WIP) Dies kopiert die nächsten Normalen vom Quellobjekt zum Bruchobjekt und verbirgt Risse besser auf glatten Objekten.
<br /> Hinweis: funktioniert nur richtig, wenn es keine Modifikatoren vor dem Bruchmodifikator gibt! Es sollte deaktiviert werden, wenn man hohe Automerge-Entfernungen und Voronoi + Bisect verwendet.

<b> Normale Suchradius: </b> Radius, in dem nach gültigen Normalen gesucht wird. Höhere Zahlen verlangsamen den Prozess. Siehe auch Einstellungen Vorschläge unten.
  
<b> Konvertieren in Objekte: </b> Konvertiert die Modifikator-Shards und Constraints in einzelne starre Body-Objekte und einzelne Constraint-Objekte. Dies könnte viel Gedächtnis auf viele Scherben verbrauchen, da man viele einzelne Objekte in Blender schaffen muss, die langsam und ressourcenintensiv ist. Die daraus resultierenden Scherben können dann wie jedes andere Objekt verwendet werden.

<b> Konvertieren in Keyframed-Objekte: </b> Konvertiert die Rigid-Body-Modifikator-Shards in Keyframed-Objekte. Dies ist nützlich, wenn Sie den Fraktur-Modifikator-Zweig zu einem offiziellen Mixer Release oder zu anderen 3D-Anwendungen und Game-Engine-Plattformen exportieren.

<br />

= Zusätzliche Panels, die mit dem Modifier und den Anpassungen hinzugefügt wurden =

[[File:User_Fracture_Modifier_Documentation_RigidBody.png|left|text-above|272px|Main Panel]]
<b> Hinweis: </b> Eine starre Körperwelt wird hinzugefügt, wenn die erste Fraktur ausgeführt wird.
<br /> Auch ein Smoke Modifier und Panel wird automatisch hinzugefügt, wenn das Rauch / Staub / Schmutz-System aus dem Fracture Helpers Addon verwendet wird.

Zusätzliche Standard-Physik-Panels werden mit diesem Modifikator aufgrund seiner Integration in die Bullet Physics-Bibliothek für Animations-Simulationen hinzugefügt. Sie beinhalten starren Körper, starre Körperkollisionen und starre Körperdynamik. Weitere Informationen zu den Standardeinstellungen finden Sie in der Dokumentation zur Bullet Physics.

<b> Benutzerdefinierte Einstellungen für Physik-Panels hinzugefügt durch Fraktur-Modifikator - </b>

<b> Vorhandenes Panel: Starrer Körper </b> <br />
Typ: Aktiv <br />
Tickboxen hinzugefügt "Triggered and Trigger" <br />
<b> Ausgelöst: </b> "Erlaube den kinematischen Zustand durch Kollisionen zurückzusetzen" <br />
<b> Trigger: </b> "Kann die Aktivierung anderer animierter Objekte auslösen, die eingerichtet werden, um ausgelöst zu werden"

<b> Neues Panel: Rigid Body Trigger Advanced </b> <br />
Tickboxes hinzugefügt "Ghost, Trigger auslösen, Constraints auflösen, dynamischer Trigger auflösen, Plastic Constraints auflösen und Stop Trigger"

<b> Ghost: </b> "Kollidiere nicht mit dem Objekt, sondern kann auch andere animierte Objekte aktivieren" <br />
Geht durch andere starre Körper, erzeugt aber Kollisionsinfos (und kann also Objekte zusammen mit Auslöser aktivieren, während sie sie nicht wegschieben.)

<b> Ausbreiten Trigger: </b> "Kann einen Trigger-Aktivierungsimpuls, der von einem auslösbaren ACROSS-auslösbaren Objekten empfangen wird, propagieren, Cluster für die INNER-Objektausbreitung verwenden!" <br />
Wenn ein Shard mit einer Trigger-Eigenschaft Scherben eines Objekts mit dem Ausbreitungsauslöser aktiviert hat, werden die Hit-Shards nicht nur aktiviert, sondern auch im Moment ihrer Aktivierung ausgelöst, sie können den Triggerimpuls auf weitere ausgelöste Objekte übertragen.

<b> Auflösen von Constraints: </b> "Löscht Einschränkungen für Shards des Auslösers TARGET" <br />
Dies ist eine Eigenschaft für ein Zielobjekt und bedeutet, dass alle Einschränkungen, die an aktivierten Scherben angehängt sind, sofort nach dem Treffen brechen werden.

<b> Dynamischer Trigger: </b> "Triggert einen dynamischen Bruch unabhängig von der Kraftschwelle" <br />
Erlaubt das Brechen von dynamischen Bruchobjekten unabhängig von der dynamischen Schwellenkraft. Normalerweise bedeutet dies, dass sie sofort brechen werden, wenn sie von einem Objekt mit dieser Eigenschaft aktiviert werden. Zusammen mit Limit-Auswirkungen, wenn das Trigger-Objekt kleiner als das ausgelöste ist, können Sie den Bereich der Punktwolke begrenzen. Dies schafft ein unregelmäßiges Bruchmuster.

<b> Lösen Sie plastische Einschränkungen: </b> "Löscht plastische Einschränkungen auf Scherben dieses Triggerziels, nur relevant für den externen Modus" <br />
Gleiche Logik wie Auflösen von Einschränkungen, gilt aber nur für plastische Einschränkungen und nur im externen Bruchmodus.

<b> Stop Trigger: </b> "Kann die Deaktivierung anderer simulierter Objekte auslösen, die eingerichtet werden, um ausgelöst zu werden" <br />
Bei Kontakt mit einem Objekt mit dieser Eigenschaft wird der betroffene Shard sofort aufhören zu bewegen und wird kinematisch, wenn seine Geschwindigkeit unterhalb der Linear- oder Winkelgeschwindigkeit im Bereich der starren Körperdynamik liegt. Funktioniert auch, wenn der Wert grau ist, wenn Enable Deaktivierung deaktiviert ist. Es ist ähnlich wie Enable Deactivation, aber das scheint man zu unzuverlässig, da es die Objekte nicht stoppen wird, indem man sie kinematisch macht. Sie werden nur schlafen und können bei einem weiteren Kontakt wieder aktiviert werden, während die gestoppten Gegenstände kinematisch bleiben und so gestoppt werden, obwohl andere Scherben immer noch mit ihnen kollidieren können.

<br />

= Scherben und Cluster verstehen =
Wenn Sie 100 Shards und 10 Cluster haben, erhalten Sie 10 Cluster von jeweils 10 Shards. Wichtig: Cluster arbeiten nur in Verbindung mit Einschränkungen, also ermöglichen sie auch. (Sie sind nur zusammen mit einer separaten, höheren Schwelle verklebt) Ändern der Cluster-Nummer beeinflusst nur ... die Cluster-Nummer ja, das ist beabsichtigt.

Das Ändern der Cluster-Nummer ändert grundsätzlich die Größe und Form der Cluster unter Beibehaltung der gleichen Shard-Count (Sie müssen beide ändern, wenn Sie mehr Shards und Cluster wollen). Und das Ändern der Shard Count oder Cluster zählen erfordert eine Refraktion, weil die Zuordnung, die shard gehört zu welchem ​​Cluster im Bruchschritt bereits geschieht und entsprechend dazu werden sie verbunden, wenn Einschränkungen aktiviert sind. Sie können auch den Seed-Wert verwenden, um die Bruchformen zu ändern (ein bisschen) und damit die Cluster, die sich auch aus ihnen ergeben.

Zusätzlich, um einen schnellen Effekt zu sehen, könntest du den Clusterwinkel auf 0,1 (auf den gebrochenen Standardwürfel, mit 100 Shards und 10 Clustern) einstellen und den Cube ein bisschen drehen, so dass er auf einer Ecke ruht, dann Animation anfängt und wenn er schlägt der Boden sollte sich im Grunde an seine Cluster zerlegen. Cluster-Winkel ist eine der besonderen Bruchbedingungen, die die regulären Schwellenwerte überschreiben. (so Scherben oder Cluster brechen, wenn es einen gewissen Winkel zwischen ihnen gibt)

<b> Shard-Massenverteilung. </b> Bei der Fraktur wird die Gesamtmasse eines Objekts nach ihrem Volumen an die Scherben verteilt. Das ist vielleicht nicht sichtbar, wenn man zB 1000 Scherben und Gesamtmasse 1 hat. Das ist, weil jeder Scherben eine sehr geringe Masse hat als die minimale Masse, die die Objekte gleich schwer macht. Erhöhe die Gesamtmasse des Objektes, wenn mehr Masse pro Scherbe gewünscht wird.

<b> Ein neues Kontrollkästchen "Initial Particle Coordinates verwenden" wurde hinzugefügt </b> welches bei der Überprüfung die Partikel-Geburtskoordinaten und die Koordinaten aus dem aktuellen Simulationszustand des Partikelsystems verwendet. In deiner Mischung musst du es deaktivieren und wenn du Autoexecute einsetzst und deinen Würfel ein bisschen um das Netz ziehst, könnte je nach seiner Position falsch oder richtig aussehen.

<b> Dynamic Fraktur </b> ist eine leistungsstarke Technologie für VFX- und Zerstörungsarbeiten. Seien Sie geraten, wenn Sie hohe Shard-Zählungen haben (25 + kann hoch sein) in Verbindung mit niedrigen Schwellenwert und niedrigen minimalen Größe die Berechnungen können erheblich verlangsamen Leistung.

<b> Helper Objects Addon. </b> Im Zweig-Download ist ein Addon namens Fracture Helpers enthalten. Sie können es aus den Menüs aktivieren. Datei> Benutzereinstellungen> Addons> Objekt: Bruchhelfer. Oder es kann von der Schaltfläche "Von der Datei installieren" auf der Unterseite der Registerkarte Addons installiert werden.

Es fügt eine Tool-Shelf-Registerkarte namens Fracture hinzu. Dieses Addon macht es einfacher, Formen und Linien zu verwenden, um das Aussehen der Fraktur sowie andere Workflow-Verbesserungen zu kontrollieren. Neuere Versionen können von der DF-VFX-Website heruntergeladen werden. Weitere Informationen finden Sie auf der Website von DF-VFX unter http://df-vfx.de/fracturemodifier/learn-fracturing/ addon Tutorial.

Es gibt auch ein Tortenmenü, das auf dem Fracture Helpers Addon basiert. Weitere Informationen und einen Download-Link finden Sie auf unserer [https://blenderartists.org/forum/showthread.php?343637-Custom-Build-Blender-Fracture-Modifier&p=3227562&viewfull=1#post3227562 BA Forum Thread].

<b> Mehr neue Shard- und Cluster-Dokumente kommen bald! </b>

<br />

= Grundlegendes zu Constraints =

Die Constraint Type-Einstellung kann nun auch die Art der Constraints überschreiben, die zwischen allen Shards generiert werden. Fixed ist die Voreinstellung und vor allem nützlich für "solide" Shattering. Punkt kann in Verbindung mit der neuen Automerge-Funktion nützlich sein, um "Tuch zu fälschen" und die Verformung zu bewältigen, wie beim Biegen von Metall und dem Verformen von Kunststoff.

Constraint-Typ wird zwischen allen Einschränkungen angewendet. Cluster ist nur zwischen Scherben, die sich in verschiedenen Clustern befinden. Constraint-Typ ist zwischen Constraints mit derselben Cluster-ID. Verwenden Sie Punktbeschränkungen für Tuch reißen zum Beispiel. Biegen zum Beispiel wird einfach mehr natürlich und besser mit Zwängen, die auch einige beugen.

Mit der neuen Constrained Collision-Einstellung ermöglicht es eine Selbstkollision mit Fracture Modifier "Fake Cloth", bei der Stücke zum Beispiel noch halb an der Masche befestigt sind. Es kann Selbstfälschungen bei der Verwendung von Punktbegrenzungen und Automerge als eine Möglichkeit, um gefälschte Tuch zum Beispiel zu machen. Ein weiterer kluger Gebrauch wäre mit einem "Ring" von Würfeln, wo 1 Würfel fehlt so eine Art offene Schleife, die zeigt, dass die verbundenen Würfel eine "Zwangsinsel" bilden. Wenn sie irgendwo brechen, werden die Zwangsinseln aufgeteilt. Also lasst uns sagen, es bricht in 2 Stücke, dann bekommst du 2 Zwangsinseln. Würfel, die in verschiedenen Inseln sind, werden zusammenstoßen, aber nicht, wenn sie auf derselben Insel sind. Bei eingeschränkter Kollision werden sie immer kollidieren.

Alternativ können Sie weitere Einschränkungen erstellen, um ein stabileres Objekt zu erhalten und in der Simulation zu scheiden. Die Grenze bestimmt, wie viele andere Scherben gleichzeitig mit einer Scherbe verbunden werden können. Der Kontaktabstand kann abgesenkt werden, um "lange Reichweite" Einschränkungen zu vermeiden, die sehr weit voneinander entfernte Objekte miteinander verbinden. Beide begrenzen die Gesamtbeschränkungszählung, die das Simulationsverhalten und die Geschwindigkeit beeinflusst.

Weniger Einschränkungen bedeutet weniger stabile, aber schnellere Simulation. Weitere Einschränkungen bedeutet ein langsameres sim, aber stabileres Objekt. Mit einer gleichwertigen Schwelle sollten sich Scherben längere Zeit zusammenhalten.

Mit Constraint Deform Einstellungen Winkel und Distanz (die nützlichsten Einstellungen) machen Deformation persistent bei Überschreitung bestimmter Winkel oder Entfernung. Cluster-Winkel, Cluster Distance sollte nur für Shards von verschiedenen Clustern gelten, aber in der Praxis derzeit nicht sehr nützlich. Gewichteter Deformwinkel, gewichteter Abstand modifizieren den Deformwinkel und den Abstand um die Schwellenwertkarte. Wahrscheinlich auch nicht sehr nützlich in der Praxis derzeit.

Deform Schwächungsfaktor multipliziert die Schwelle (!) Mit 1-Faktor jedes Mal, wenn eine Verformung persistent (Winkel oder Abstand überschritten), um zu simulieren, dass kontinuierlich Biegen Metall in entgegengesetzte Richtungen könnte es in der Mitte brechen.

Deform Workflow Side Hinweis: Deform wird verwendet, um die deformierte Form zu halten, um Metall wie in persistenten Verformung zu fälschen. Minimal gibt es kein Zurückspringen in die ursprüngliche Form, aber es könnte sich noch weiter biegen, wenn der Winkel zu niedrig ist.

Fake Cloth passiert meistens mit dem Automerge Distance und führt Merge-Einstellungen durch. Die Verwendung dieser beiden Einstellungen führt zu metallischen Blättern, indem sie das Fake Cloth "beharrlich" verformen, indem sie die Beschränkungen auf einer Frame-by-Frame-Basis wieder aufbauen. Man baut grundsätzlich oben auf jedem nachfolgenden. Der Workflow passt zuerst die Einstellungen an, um Fake Cloth zu haben. Fügen Sie dann Deform-Einstellungen hinzu, um die Deformationen anhaltender zu machen.

Die Deform-Einstellungen können auch ohne Automerge-Distanz verwendet werden, um etwas mit den ursprünglichen Lücken zu verformen. Ein Anwendungsfall würde gebrochenen Beton mit gebogenen Bewehrung innen machen. Die Bewehrung müsste visuell hinzugefügt werden.

<b> Besondere Anmerkung über Einschränkungen: </b> Das erweiterte Constraints-System des Fracture Modifier kann ohne eigentliches Brechen und Objekt verwendet werden. Legen Sie einfach die Shard-Zählung auf 1 und dann die Zusammenstellung von Beziehungen zwischen mehreren Objekten über Gruppierung, Erziehung und Verwendung von Leergut dann Ausführen Fraktur. Dies kombiniert mit Constraint-Einstellungen ermöglicht einige wirklich fortgeschrittene Objekt-Interaktionen ohne jedes einzelne Objekt Frakturieren oder brechen auseinander in Scherben. Zum Beispiel kann eine Animation aus einer Tasse geschüttelt werden und Würfel rollen herum drinnen. COOLES ZEUG!

<b> Mehr neue Constraint-Dokumente kommen bald! </b>

<br />

= Verstehen von Fracture Utilities =

Autohide und Automerge werden überarbeitet. Verwenden Sie Autohide, um innere Gesichter wie üblich zu verstecken, aber zusätzlich in Verbindung mit Automerge Abstand zu "track" verts in der Nähe bis zum autohide Abstand (um freigegebene Verts zu erkennen).

Benutze Automerge, um geteilte Verweise zusammen zu halten, bis das Automerge dist überschritten wird. (Möge das Mesh durcheinander bringen, wenn ich in bestimmten Situationen zu große Werte habe!)

Halten Sie Verzerrung versucht zu halten Deformationen passiert bei "reißen" persistent. Möglicherweise unvorhersehbares Verhalten in nachfolgenden Läufen zeigen, da es einen Optimierungsschritt intern auf dem letzten Frame gibt, um unveränderte gemeinsame Scheitelpunkte zu erkennen, die in den nachfolgenden Läufen nicht wieder berücksichtigt werden. Ändern von Autohide Distanz könnte dies vorübergehend lösen, wenn Probleme auftreten. Gebrauch mit Sorgfalt ...

Führen Sie Merge tatsächlich Schweißung Geometrie, die eng beieinander durch Automerge und Doppelte entfernt. Warnung: ändert Topologie und kann langsam sein! Autohide ändert auch die Topologie.

Fake Tuch ist am besten mit Voronoi + Bisect auf flache oder sehr dünne (Solidify Modifier) ​​Geometrie erreicht. Es ist nicht so gut mit solider Geometrie, könnte aber in einigen Fällen arbeiten. Vermeiden Sie Methoden, die hier innere Gesichter schaffen, verwenden Sie hier nur Voronoi + Bisect oder Fast Bisect.

Konvertieren in Keyframes erscheint jetzt einen Dialog. Start / End Frame sind wählbar, sowie Schrittgröße. Zusätzlich kann ein Schwellenwert hinzugefügt werden. Das Verhältnis der Veränderung zwischen alt und neu loc / rot vor Keyframe ist grob gesprochen. Je niedriger die Schwelle, desto mehr Keyframes sollten gesetzt werden (auch zwischen den Schritten), Schwelle = 0, setzen bei jedem Schritt nur Keyframes. Es gibt Schritt Keyframes und Schwellen basierte adaptive Keyframes dazwischen. Verwenden Handles glättet Schrittgriffe und macht adaptive Griffe Vektor. Dies ist bei größeren Schrittweiten nützlich, um zu vermeiden, dass einige detaillierte Kollisionsinformationen bei der Einstellung von Keyframes verloren gehen.

<br />

= Zusätzliche Workflow-Informationen =
(Anmerkung: Fracture Helpers Addon-Dokumentation wird in Kürze bekannt gegeben. Jetzt sehen Sie bitte [[http://df-vfx.de/fracturemodifier/learn-fracturing/ DF-VFX's Tutorials]])
<b> Verwenden des Partikelsystems auf dem Originalobjekt oder auf Helperobjekten: </b> <br />
Füge das Partikelsystem vor dem Frakturmodifikator immer im Stapel hinzu.
In Partikel-System brauchen Sie nicht die "Use Modifier Stack", wenn Sie wollen, um Partikel aus den Scherben zu emittieren. Alternativ können Sie den Partikelsystem-Modifikator unterhalb des Frakturmodifikators platzieren. Verwenden Sie Modifier Stack Tick-Box ist ein bisschen seltsam dort.

Es empfiehlt sich, das Partikelsystem während des Rahmens 1 oder des starren Cache-Startrahmens einzurichten. Setzen Sie es auf Volume, Random und lassen Sie alle Partikel auf Frame 1 emittieren. Um dies zu tun, setzen Sie Emission Start und Emission Ende auf Frame 1. Die Partikel-System-Display könnte visuell unzuverlässig sein, aber die Partikel-Geburt Koordinaten sollten sowieso gültig sein.

Dann unter experimentell können Sie "Eigene Partikel" als Punktquelle angeben. Sie können das Partikelsystem über Textur manipulieren, um beispielsweise die Partikelverteilung zu manipulieren und damit die Eingangspunktwolke zu unregelmäßigen Scherben zu bekommen.

Alternativ können Sie ein Partikelsystem auf einem anderen Objekt angeben. Dies muss in eine Gruppe eingefügt werden und diese Gruppe wird mit dem Modifikator als "Extra Group" verknüpft. Sie müssen dann "Extra Partikel" als Punktquelle verwenden. Eine Gruppe wird verwendet, da Sie auf diese Weise mehrere Objekte als Helferobjekte hinzufügen können.

Zum Beispiel können Sie die Punktwolke dichter machen, wenn Sie ein Partikelsystem auf ein kleines Helferobjekt legen und es in das ursprüngliche Objekt legen, das Sie brechen möchten. In der Umgebung des Helferobjekts werden die Scherben kleiner als überall im ursprünglichen Objekt. Du bekommst größere Scherben weiter weg vom Helferobjekt.
Wenn du auf Gesichter emittierst, kann Boolean in Schwierigkeiten geraten, und mit bisect füllen vermutlich auch weil du nahe am Rand der Begrenzungsbox bist.

Die voronoi-Methode zerlegt immer die gesamten Objekte, die Scherben werden größer, weil diese Zellen im Grunde "offene" Zellen sind, nur die Container- oder "Grenz" -Zellen beschränken sie.
Für mehrere Helfer-Objekte, wenn Sie einige Objekte haben, jeweils mit Partikel-System und alle in der "Extra" -Gruppe, ihre Partikel alle Punkte in die Punktquelle hinzufügen.

<b> Ground Plane Interaction: </b> <br />
Hier sind zusätzliche Informationen über die Einstellungen, wo Kollision mit der Grundebene nicht zu einem unerwünschten Bruch führt.
Eine Technik ist, ein Loch in den Boden zu machen. Das Loch in den Boden in der Holzmischung Beispiel ist eine Tasche, die verhindern sollte, dass das gesamte Objekt auf die Seite fallen, wenn getroffen. Aber das ist nicht sehr zuverlässig und langweilig, jedes Mal einzurichten.
Für das Kleben von Objekten zu einer passiven Grundplatte Sie im Grunde Gewicht paint diejenigen Bereiche berühren den Boden mit einem Gewicht von 1,0. Sie müssen das Objekt vor dem Hinzufügen des Modifikators malen, denn im Moment können Sie das Gewichtspapier auf dem Objekt nicht sehen, wenn der Modifikator aktiviert ist. Ein Gewicht von 1,0 wird empfohlen, weil das Shard-Gewicht als Durchschnitt von allen Ecken, die zur Bruchscherbe gehören, berechnet wird und je mehr Verts ein Gewicht haben = 1, desto höher ist die Wahrscheinlichkeit, dass die gesamte Scherbe ein Gewicht von> 0,5 und wird während der Simulation als passiv betrachtet.

Nachdem Sie das Originalobjekt fertiggestellt haben, erhalten Sie eine Vertexgruppe als "Ergebnis". Dies muss vor dem Bruch in den Modifikator verknüpft werden. Wenn Sie dann die Fraktur ausführen, werden die Gewichtsfarben von der ursprünglichen Geometrie zu der gebrochenen interpoliert und die Scherbegewichte werden aus den interpolierten Scheitelgewichten wie oben beschrieben berechnet.

Wenn Sie feststellen, dass sich die gewünschten passiven Bereiche des Objekts während der Simulation noch bewegen, müssen Sie mehr von der ursprünglichen Masche mit einem hohen Gewicht malen. Hinweis: Es könnte helfen, das ursprüngliche Objekt zu unterteilen, um mehr Kontrolle über die Gewichtsfarbe zu haben und eine genauere Gewichtsinterpolation zu den Scherben zu ermöglichen. Dies ist eine andere Technik, wenn man keine Löcher in den Boden schneiden will.

<b> Andere Techniken: </b> <br />
1) Habe das Objekt den Boden berühren, damit es nicht weiter herunterkommt <br />
2) Deaktivieren Sie die Schwerkraft (dies sollte auf Objektbasis gemacht werden, nicht auf Szenenbasis, wie es jetzt ist), wahrscheinlich keine Option, da man die Feldgewichte nicht animieren kann, wie es scheint <br />
3) Verwenden Sie "Start Deaktiviert" und das Objekt wird bei Kollision dann aktiviert (und beginnt zu fallen) <br />
4) Verwenden Sie Einschränkungen und "gute" Einstellungen für Schwellenwerte, so dass ein Objekt, das den Boden berührt, nicht durch seine eigenen zusammenbrechen wird. Sie müssen experimentieren und ausprobieren, indem Sie die Simulation durchführen, bis Sie die gewünschten Ergebnisse erhalten. <br />

<b> Verwenden von zusammengesetzten Objekten: </b> <br />
Für eine Wand von zusammengesetzten Objekten (Bretter, Balken und Gips).
Grundsätzlich brüllst du zuerst die einzelnen Objekte mit den voronoi Methoden, dann bewerbe dich.
Dann verbinden Sie alles zusammen und brechen Sie die vorhandenen Scherben (mit einer "ungültigen" Quelle, wie Extra Partikel ohne Helferobjekt), dann erhalten Sie ein simulierbares Einzelobjekt.

Apply ist nicht ein guter Ansatz, aber im Moment gibt es kein realisierbares Konzept, wie man einzelne Objekte unter 1 Modifikator anschließen kann, weil dieses Konzept Blender unbekannt ist.

== Erweiterte Workflow-Informationen ==
(Dieser Abschnitt ist ein Work-in-Fortschritt Stub und wird kontinuierlich verbessert)

<b> Vertex-Gruppen und Gewichtung: </b> <br />
Dies kann verwendet werden, um erweiterte Frakturen und Kontrolle zu bekommen. Sehen Sie sich die anderen experimentellen Einstellungen und Ground Plane Interaction Abschnitte oben. (Weitere Workflow-spezifische Informationen werden in Kürze hier hinzugefügt.)

<b> Interaktion mit starren Körperbeschränkungen zu und von gebrochenen Objekten: </b>
<br /> Derzeit mit einem gebrochenen Objekt und macht eine starre Körperbeschränkung mit und leeres Objekt zu einem anderen Objekt wird nicht direkt unterstützt. Als Workaround können Sie versuchen, sich den Objekten anzuschließen und den Modifikator auf die vorhandenen Inseln zu setzen und zu verwenden, aber derzeit nur die "Fixed" -Beschränkung ist dafür implementiert. Eine andere Technik zu versuchen ist, den Modifikator in getrennte Objekte mit der Schaltfläche "In Objekte konvertieren" umzuwandeln, ganz unten im Abschnitt "Experimentell". Dann können einzelne Objekte bearbeitet werden, wenn das ist was gewünscht wird.

<b> Fortgeschrittene UV-Mapping: </b>
<br /> Derzeit innere Gesichter erhalten keinen UV. Innenmaterialien können neuen gefüllten Gesichtern aus Booleschen oder Bisect + Füllmethoden zugeordnet werden. Bestehende UVs auf Außenflächen sind zum größten Teil erhalten. Hinweis: Einige Optionen unter Experimentell funktionieren nicht ganz mit CustomData wie Texturen. (Mehr Workflow-spezifische Informationen werden in Kürze hier hinzugefügt.)

<b> Verwenden der Unterobjektgruppe: </b>
<br /> Diese Funktion beabsichtigt, mehrere abgeleitete Maschen verschiedener Objekte mit verschiedenen Modifikatoreinstellungen zusammen in einem "Kollektor" -Objekt zu verbinden. Dann beschränken Sie regelmäßig Scherben verschiedener Objekte zusammen. Aber das kann nicht die gewünschten Ergebnisse geben. Hinweis: Versuchen Sie NICHT, im Kollektorobjekt zu brechen. Es wird das Netz verschmelzen. Nur RE-USE die Scherben dort und Texturen etc. Alle Customdata Zeug funktioniert nicht dort.

Eine Möglichkeit zum Experimentieren ist, alle Objekte mit Frakturmodifikatoren in eine Gruppe zu bringen und sie einem anderen Objekt als Unterobjektgruppe zuzuordnen. Dann wähle extra Partikel (OHNE Helferobjekt ...) Wenn alles gut funktioniert, bekommst du eine "zusammengeführte" Kopie aller Objekte aus der Subobjektgruppe in deinem "Sammler" Objekt. Da es dann in einem abgeleiteten ist, kannst du das zusammenzwingen. Aber Vorsicht, viele ODD Ergebnisse immer noch mit diesem passieren.

<b> Arbeiten mit Glasmaterialien: </b>
<br /> Die aktuelle empfohlene Methode ist die Verwendung der Autohide Distance, Automerge Distance, Smooth Objects und Fix Normals Einstellungen, um die Risse vor dem Zusammenstoß mit einem Objekt zu halten. Das Rigid Body Dynamics Panel hat auch Physik Deaktivierungseinstellungen, die im Timing der Trennung nützlich sind.

Es gibt auch eine Technik von Bashi zum Entfernen von inneren Polygonen, bevor sie auseinanderbrechen. Dies wird vor allem für Glaswerkstoffe verwendet. Siehe den folgenden Thread: [http://blenderartists.org/forum/showthread.php?343637-Custom-Build-Blender-Fracture-Modifier&p=2713632&viewfull=1#post2713632 Bashi's BA Post]

<b> Exportieren von Animationen in andere Blender-Versionen und Spiele-Engine-Plattformen </b>
<br />
Die aktuell empfohlene Methode verwendet die Funktion Convert to Keyframed Objects. Dies wird die gespeicherten Scherben in reguläre Mixerobjekte umwandeln und die Animationsimulation umschalten. Das ist ähnlich wie die Idee des Backens.

Eine zusätzliche Technik zu versuchen ist, mit MDD und MeshCache Modifier zu exportieren. Im Falle der Wiederverwendung in einer Blend-Datei versuchen Sie ein verbundenes Netz der Inseln.
<br /> (Weitere Workflow-spezifische Informationen werden in Kürze hier hinzugefügt.)

== Zusätzliche Workflow-Links ==
(HINWEIS: Klicken Sie mit der rechten Maustaste auf den Link und klicken Sie auf eine neue Registerkarte oder ein Fenster, um auch auf dieser Seite zu bleiben)

[http://blenderartists.org/forum/showthread.php?343637-Custom-Build-Blender-Fracture-Modifier&p=2960861&viewfull=1#post2960861 Kontrolle der Lage der Frakturen und Shard-Größe]

[http://blenderartists.org/forum/showthread.php?343637-Custom-Build-Blender-Fracture-Modifier&p=2958069&viewfull=1#post2958069 Testen von Rauch aus Innengesichtern]

[http://blenderartists.org/forum/showthread.php?343637-Custom-Build-Blender-Fracture-Modifier&p=2956768&viewfull=1#post2956768 Gewicht Malerei, um Fraktur zu kontrollieren]

[http://blenderartists.org/forum/showthread.php?343637-Custom-Build-Blender-Fracture-Modifier&p=2916220&viewfull=1#post2916220 Erstellen von kreisförmigen Rissen zu simulieren bullet wie Auswirkungen Frakturierung]

[http://blenderartists.org/forum/showthread.php?343637-Custom-Build-Blender-Fracture-Modifier&p=3053403&viewfull=1#post3053403 UE4- und Unity-Workflows für den Import von Fracture Modifier-Animationen über FBX]

<br />

= Allgemeine Tipps =

* Maschen sollten wasserdicht (nicht verteiler) für boolesche sein, wenn innere Oberflächen gewünscht werden. Dies ist, weil bisect mit inneren Oberflächen ist nicht sehr zuverlässig auf komplexere Objekte. Aber schnell bisect zum Beispiel lässt offene Stücke und sollte für fast alle Maschen arbeiten.

* Zusätzliche Anmerkungen zu voronoi, bisect und boolean: voronoi zerlegt die Bounding Box im ersten Schritt, und im 2. Schritt machst du Boolean mit jedem Zelle Gesicht oder bisect mit jedem Zelle Gesicht oder schnelle Bisect verwendet 1 zufällige Gesicht jeder Zelle nur. Bisect + Füllung grundsätzlich schneidet das Gitter in Hälften entlang der Zelle Gesichter, die als Ebenen behandelt werden und versucht, die Innenflächen zu füllen. Bisect füllt nicht Fast bisect ist eine andere Variante, mit einer zufälligen Gesicht pro Zelle nur und im Grunde schrumpfen die verarbeitete Mesh in jedem Schritt durch Sortierung der Scherben nach ihrer Größe und Aufteilung der größten immer. Boolean und Bisect werden aus der Mixcode-Basis wiederverwendet.

* Bei der Verwendung von Clustern kann es notwendig sein, Änderungen an Parametern in Cluster-Einstellungen vorzunehmen. (TODO, untersuchen, ob dies und FM oder ein Blender Bug.)

* Diagonale Splitter können durch Drehen des Objekts im Bearbeitungsmodus erreicht werden. Da dies eine Rotation "ins Mesh" im Grunde hinzufügt. Objektdrehung nimmt dann die Splitter mit, da das Splittern nur die lokale Achse beeinflusst.

* Mit Grease Pencil gibt es eine Option, um die langen Linien / Striche als Rand-basierte Fraktur Quelle verwenden, aber es ist nicht zuverlässig. Achten Sie darauf, den Schlaganfall außerhalb des Netzes zu starten und zu beenden, das Sie brechen möchten. Erhöhen Sie auch die Einstellung "Offset" mehr, da sie die Mesh "Tiefe" entlang der Achse überschreiten muss, die Sie wählen, um den Schnitt zu projizieren. Nur globale X, Y, Z werden unterstützt, um zu projizieren.

* Um Objekte einfacher zu brechen, kannst du die Masse skalieren, so kannst du auch Schwellenwerte skalieren und musst nicht im Bereich von 0,000x herumgehen. Höhere Massen schaffen höhere Kräfte in der Simulation.

* Um die Einschränkungen zu begrenzen, verwenden Sie die pro Inselzählung oder einen Suchbereich, dies kann das Bauen zu "lang" der Einschränkungen vermeiden.

* Wenn ein Bruchproblem in boolean aufgrund von Float-Einschränkungen auftritt, skaliere das Mesh im Bearbeitungsmodus und skaliere dann im Objektmodus zurück. Dies kann zumindest diese Probleme beseitigen, aber es könnte die sim beeinflussen.

* Sie können die Schwellen mit einem Bruchwinkel, Abstand oder Prozentsatz überschreiben (bedeutet, wenn x Prozent aller Einschränkungen einer Insel gebrochen ist, der Rest wird auch brechen). Das ist so baumelnde Inseln fallen leichter ab.

* Sie können vorhandene Netzinseln als Scherben verwenden, wenn Sie eine ungültige Punktquelle angeben, LIKE extra Partikel mit NO Helper Gruppe ausgewählt. Das wird die Inseln wiederverwenden.

* Um zusammenzubauen zusammengesetzte Objekte Fraktur ein Objekt, gelten, Fraktur ein anderes, bewerben, verbinden Sie das Netz, und richten Sie einen neuen Modifikator mit ungültiger Quelle -> Sie erhalten eine Simulations-Verbindung, wo alle Scherben miteinander interagieren können. Sie sind nicht durch Objektgrenze begrenzt.

* Nach anderen Modifikatoren, die dauerhaft ausgeführt werden, verlangsamt sich die Sim-Geschwindigkeit, es sei denn, sie würden ihre Ergebnisse auch während der Sim-Cache cache. Aber derzeit nur dieser Frakturmodifikator tut dies.

* Unter Windows automatische Bestimmung der bbox längste Seite hat Probleme. Wenn du die Einstellung 0 eingibst, bekommst du oft Müllwerte, also ist es besser, es zu vermeiden.

<br />

= Einstellungen Vorschläge =

<b> Vorschläge für einige Einstellungen für unterschiedliche Ergebnisse und Experimente: </b>

<b> Das Versuchen der verschiedenen Algorithmen </b> würde vier Möglichkeiten umfassen.
Es gibt mehr mit / ohne Einschränkungen, hohe / niedrige Schwellen, Bruchwinkel, brechen Prozentsatz.
Es hängt davon ab, wie du den Effekt aussehen möchtest.

<b> Höhere starre Körpermassen </b> werden wahrscheinlich einige unterschiedliche Ergebnisse schaffen.

<b> Einschränkungsgrenzen </b> (Abstands- und Zahlengrenze)
gute Einstellungen können Abstand = 1 sein und um 5-6 begrenzen.
Sie können Abstand zu 0 setzen, dann wird es max bbox Länge als Abstand nehmen (und legen Sie es auch in der GUI, also fragen Sie sich nicht darüber ...)

<b> Je mehr Einschränkungen </b> desto langsamer wird es sein, aber auch stabiler (wird nicht so leicht zusammenbrechen)
Überprüfen Sie die Terminal-Konsole vielleicht, wie viele Einschränkungen tatsächlich gebaut wurden (es ist dort gedruckt).

<b> Je kleiner die Scherben sind mit Einschränkungen </b> je kleiner der Suchradius ist, um eine vergleichbare Anzahl von Nachbarn für ein ähnliches Stabilitäts- / Simulationsverhalten zu finden. Auch mit dem kleineren Constraint-Suchradius bekommst du auch eine bessere Performance auf Objekten mit vielen kleinen Scherben, da die Einschränkungszeit viel schneller ist als bei einem größeren Radius.

<b> Für Vertex-Constraint-Ziele </b> verwenden Sie kleine Werte wie 0,01 oder so oder Blender wird dazu führen, dass Blender hier hängt (TODO)

<b> Wenn Schwellen oder Kontaktdistanzen zu hoch sind </b> Sie erleben gummiartiges Verhalten, schwächen Schwachstellen oder erhöhen die Masse oder verwenden das Kontrollkästchen Massenabhängige Schwellen, das multipliziert die maximale Schwelle mit dem Massenanteil der Scherbe.
Für starre Körper Kollision Formen verwenden Convex Hull für die Scherben. Wenn Sie dies auf das Hauptobjekt anwenden, gilt es für alle Scherben automatisch.

<b> Bei mehreren Objekten in einer Szene </b> kannst du auch alle Frakturmodifikatoren auf alle Objekte anwenden. Dann verbinden sie sich zu einem Objekt und verwenden als Punktquelle "Extra Partikel". Dies ist eine leere Quelle, wenn Sie auch keine zusätzliche Gruppe angeben.
Der Modifikator erkennt dies und zerlegt es dann in die gegebenen Inseln. Das ist besonders nützlich, wenn man für Fraktionen unterschiedliche Teile benötigt.
Dies ist zB für eine Holzwand nützlich. Es könnte Bretter und Putz haben.
<br /> <b> HINWEIS: </b> Es ist besser, die Texturen auf die Objekte zu setzen. Boolean und Bisect sollten die UVs behandeln.

<b> Mit komplexen Objekten </b> Wahrscheinlich wird Boolean sowieso scheitern und bisect füllt die Gesichter nicht zuverlässig aus (es ist der Standard-Bisect-Füllcode von Blender, der verwendet wird.)
Dreieck füllt schrecklich, aber Edgnet-Füllung ist nicht viel besser aber (interne Bisect-Füllung Algorithmen).
Nach einem Entwickler ist das "erwartete Verhalten". : S

<b> Wenn boolean bei kleineren Objekten fehlschlägt </b> könnte es helfen, sie im Bearbeitungsmodus zu vergrößern. Dann gib es im Objektmodus wieder ab (Float-Ungenauigkeiten treten meist bei zu kleinem oder zu großem Objekt auf).
Das Ändern des Samen könnte auch helfen, oder einfach nur die Anzahl der Scherben ändern.

<b> Ein Rand Split </ b> nach Fraktur hilft bei der Glättung von Objekten.
Denken Sie daran, alle Modifikatoren vor der Fraktur anzuwenden - schlechte Leistung sonst.

<b> Gewichtsmalerei auf dem ursprünglichen Netz, um eine Vertexgruppe </b> zu definieren, kann auch mit experimentiert werden. Diese Gewichte werden mit der maximalen Schwelle multipliziert, so dass höhere gewichtete Flächen aufgrund höherer Schwellen stabiler sind.

<b> Gedanken auf einem Container in einer anderen Methode. </b> Je mehr und kleinere Scherben ein Objekt zerlegt wird, desto wahrscheinlicher bekommt man keine konkaven Teile. Sie müssen Convex Hull als Rigidbody Form-Typ verwenden, weil Mesh ist sehr instabil, wenn bei aktiven / simulierten Objekten verwendet und verursacht nur Ärger. Die konvexen Rümpfe gelten nur für jede Scherbe separat, so ist es sicher, sie auf konkaven Objekten zu verwenden, da die Tatsache, dass Sie genug kleine Scherben haben, so dass Sie keine visuell konkaven Teile bekommen. Die haben noch einen konvexen Rumpf und verhalten sich auf unerwartete Weise.
Beispiel / Test Blend - TODO Update Beispiel Datei Link
In dieser Akte hat das äußere Objekt mehr Scherben, also sind sie weniger wahrscheinlich konkav.

<b> Empfohlener Workflow für die Vorbereitung von Text für Frakturen </b> Denken Sie daran, auch mit diesem Workflow, etwas Text es besser für die Umwandlung als andere. Benutzerdefinierter modellierter Text ist das Beste für Texteffekte. Dies ist der ideale Weg, dass erfahrene Text-Animatoren es tun. <br />
Der allgemeine Arbeitsablauf ist wie folgt: Umwandlung in Mesh, doppelte, begrenzte Auflösung, wahlweise Remesh, Geometrie in die Mitte von bbox setzen, um den Punkt der Masse auf die Mitte zu setzen (vermeidet "unerwartete" Bewegung während der Simulation, wie auf eine Seite fallen. Umgekehrt setzen Sie den Punkt der Masse irgendwo, wenn ein solches Verhalten gewünscht wird.) Dann verwenden Sie Boolesche, wenn fehlschlägt bisect + füllen oder bisect. <br />
<b> HINWEIS: </b> Mit dem Bevel-Befehl kann es zu einer kleinen Selbstkreuzung kommen, bei der Boolesche fehlgeschlagen sind. Manuelle Bearbeitung des Netzes kann erforderlich sein. Manuelle Bearbeitung wird typischerweise in textbasierten Meshs benötigt, da die Qualität des Originaltextes nicht für die Umwandlung in Mesh geeignet ist.

<br />

= Bekannte Probleme =

<b> HINWEIS: </b> Es gibt mehrere bekannte Probleme mit Mixer und Bullet Physics im Allgemeinen, die nicht direkt mit dem Fracture Modifier verwandt sind. Das FM-Entwicklerteam konnte einige Workarounds über benutzerdefinierte Duplikate und andere über Workflows bereitstellen. Bitte fühlen Sie sich frei, unsere Support-Links oben zu verwenden, um zu berichten, was Ihr Workflow zeigt, aber bitte im Auge behalten einige der Mängel in Mischer richtig sind außerhalb unserer Kontrolle. Lassen Sie uns wissen, was Ihre Bedürfnisse sind auf unseren Support-Links an der Spitze dieser Seite und das Team und unsere tolle Community wird helfen, so gut wir können.

- Wenn man {{Shortcut|esc}} schlägt, um eine laufende Animation zu stoppen, kann es passieren, dass eine Refraktion unabsichtlich ausgelöst wird. Das ist problematisch, besonders wenn man einen langen Bruchprozess hat.

-Older Fracture Branch Blends WILL Absturz mit den neueren baut wegen der Änderungen an Blend Loader so hüte!
Die Lösung ist, ohne Modifikator zuerst mit dem älteren Build zu speichern und dann wieder in neueren Build zu setzen.
Dann, wenn in neuem Build mit dem Modifikator gespeichert, wird es wieder funktionieren.

- NICHT versuchen, Bruch auszuführen oder die Einstellung "Use constraints" zu ändern, während eine Simulation läuft! Ein Crash bei der nächsten Ausführung der Simulation ist sehr wahrscheinlich dann (TODO)
Beachten Sie, dass die Brucheinstellungen nur dann geändert werden, wenn die Simulation gestoppt wird und der aktuelle Rahmen Frame 1 oder der starre Cache-Startrahmen ist.

-Regulale Einschränkungen funktionieren nicht mit gebrochenen Objekten. Dies ist eine bekannte Begrenzung ATM. Wenn aber feste Zwänge verwendet werden, könnten beide Objekte vor dem Bruch zusammengefügt werden. Auf diese Weise gibt es 1 Mesh, die dann mit "Split Shards to Islands" Option gebrochen werden kann. Dies zersetzt Zellen, die aus mehreren visuell unverbundenen Teilen bestehen, um Mesh-Inseln zu trennen.

-Inner-UVs können in komplexeren Setups, Workflows und Simulationen nicht wie geplant funktionieren. Bitte melden Sie diese nacheinander und das Team stellt Ihnen gerne Empfehlungen zur Verfügung.

<b>Deutsche Sprache mangling mit freundlicher Genehmigung von Google Translate!</b>
